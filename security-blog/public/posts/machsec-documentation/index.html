<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>machsec - detecting XNU binary mitigations - gracecondition</title>
    <meta name="description" content="OS internals, binary exploitation, and low-level security research">

    <link rel="stylesheet" href="https://gracecondition.github.io/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600;700&family=SF+Pro+Text:wght@300;400;500;600&display=swap" rel="stylesheet">

    

    
</head>
<body>
    <div class="site-container">
        <header class="site-header">
    <nav class="navbar">
        <div class="nav-container">
            <a href="https://gracecondition.github.io/" class="nav-brand">
                <h1>gracecondition</h1>
            </a>

            <div class="nav-menu" id="nav-menu">
                <a href="https://gracecondition.github.io/" class="nav-link">Home</a>
                <a href="/posts/" class="nav-link">Posts</a>
                <a href="/ctf/" class="nav-link">CTF Solutions</a>
                <a href="/about/" class="nav-link">About</a>
            </div>

            <div class="nav-toggle" id="nav-toggle">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>
</header>

        <main class="main-content">
            
<div class="content-with-toc">
    <aside class="toc-sidebar">
    <div class="toc-content">
        
        <div class="toc-section">
            <h3 class="toc-title">üìñ Contents</h3>
            <nav class="toc-nav" id="toc-nav">
                
                <div class="toc-loading">Generating table of contents...</div>
            </nav>
        </div>

        
        <div class="toc-section">
            <h4 class="toc-subtitle">Article Info</h4>
            <div class="article-info">
                <div class="info-item">
                    <span class="info-label">Published:</span>
                    <time class="info-value">Oct 10, 2025</time>
                </div>
                
                <div class="info-item">
                    <span class="info-label">Read time:</span>
                    <span class="info-value">35 min</span>
                </div>
                
                
                <div class="info-item">
                    <span class="info-label">Words:</span>
                    <span class="info-value">7359</span>
                </div>
                
                
                <div class="info-item">
                    <span class="info-label">Category:</span>
                    <span class="info-value category-analysis">Analysis</span>
                </div>
                
            </div>
        </div>

        
        

        
        
        <div class="toc-section">
            <h4 class="toc-subtitle">Tags</h4>
            <div class="toc-tags">
                
                <a href="/tags/example/" class="toc-tag">#example</a>
                
                <a href="/tags/analysis/" class="toc-tag">#analysis</a>
                
            </div>
        </div>
        

        
        <div class="toc-section">
            <h4 class="toc-subtitle">Progress</h4>
            <div class="reading-progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-text">
                    <span id="progress-percentage">0%</span>
                    <span class="progress-label">completed</span>
                </div>
            </div>
        </div>

        
        <div class="toc-section">
            <h4 class="toc-subtitle">Related</h4>
            <div class="related-posts">
                
                
            </div>
        </div>

    </div>
</aside>

    <article class="single-post">
        <header class="post-header">
            <div class="post-meta-badge">
                
                    <span class="analysis-badge">üîç Analysis</span>
                
            </div>

            <h1 class="post-title-single">machsec - detecting XNU binary mitigations</h1>

            <div class="post-meta-single">
                <time datetime="2025-10-10">October 10, 2025</time>
                
                <span> ‚Ä¢ </span>
                <span>35 min read</span>
                
                
                <span> ‚Ä¢ </span>
                <div class="inline-tags">
                    
                    <span class="inline-tag">#example</span>
                    
                    <span class="inline-tag">#analysis</span>
                    
                </div>
                
            </div>
        </header>

        <div class="post-body" id="post-content">
            <h1 id="what-is-machsec">What is machsec?</h1>
<p>Machsec is a custom tool I wrote to identify security mitigations on MachO binaries on iOS/macOS.
The idea came to mind when I realized there is no &ldquo;checksec&rdquo; equivalent for these platforms,
not one that can detect the unique mitigations that are present on these operating systems.
Since the mitigations are super unique, and don&rsquo;t exist in any other operating system.
Writing a tool from scratch was necessary.
Detecting mitigations present in a binary are a crucial step in understanding what kind
of exploits need to be found and abused in order to gain arbitrary code execution in them.
For example, you can not preform a ROP attack if all of your instruction pointers are  signed.
What are signed pointers? There is no such thing on other platforms? this is exactly the issue
I tried to solve with this program.</p>
<h1 id="mitigations">Mitigations</h1>
<p>Every operating system has mitigations put in place to make exploitation
more difficult.
Mitigations usually come in 3 flavors:</p>
<ul>
<li>Operating system level (ASLR/KASLR for example)</li>
<li>Compiler level (Inserting canaries into the stackframe)</li>
<li>Hardware level + operating system level+compiler level (SMAP/SMEP, PAC)</li>
</ul>
<p>Most operating systems implement the basic common mitigations that are ubiquitous,
But macOS and iOS are by far the most mitigation rich operating systems out there.</p>
<p>I will now attempt to break down almost every single major mitigation on XNU systems,
Mostly mitigations that exist on the Compiler Level / Hardware level.</p>
<h2 id="stack-canaries">Stack Canaries</h2>
<h3 id="what-are-stack-canaries">What are stack canaries?</h3>
<p>Stack canaries are one of the most common mitigations you are going to find on an operating system.
Stack canaries started becoming a thing after the phrack article &ldquo;Smashing the stack for fun and profit&rdquo;,
where the famous technique &ldquo;stacksmashing&rdquo; was popularized, also known by its other name, a stack overflow.
To understand what stack canaries are, it is integral to have a firm grasp on assembly language and how a modern computer works.
I highly recommend reading up on how assembly language works, and returning to this article afterwards, in order for things here
to make sense.
But put simply,
Every function you implement and use in any modern low level programming language, will set up a memory region for itself,
called the &ldquo;Stack&rdquo;.
It&rsquo;s a Last-in-first-out sort of data structure, where data like variables amongst other interesting things is stored for
functions to make use of.
One of those interesting things is something called the return address. Put simply, it&rsquo;s the memory address location of where to go after the function has finished running,
more specifically, it&rsquo;s the address of the function that previously called that function.
For example, let&rsquo;s imagine the following:
<code>function main --(calls)--&gt; function printf()</code>
If there&rsquo;s more logic in main after the printf, printf would need to know how to return to main.
In the stackframe of printf, the instruction pointer to go back to main is present.
The stack layout of a program&rsquo;s function might look something like this (the stackframe):</p>
<p>(represented as some sort of weird abomination of a stack)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">----</span> <span style="color:#960050;background-color:#1e0010">&lt;-</span> <span style="color:#a6e22e">$bp</span> (<span style="color:#66d9ef">base</span> <span style="color:#66d9ef">pointer</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">stackframe</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">int</span> <span style="color:#66d9ef">i</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">0x1337</span><span style="color:#75715e">;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">j</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">0x41</span><span style="color:#75715e">;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">stack</span> <span style="color:#66d9ef">canary</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">0xr4nd0mnumb3r</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">instruction</span> <span style="color:#66d9ef">pointer</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">0x80000</span> <span style="color:#960050;background-color:#1e0010">&lt;</span>-- <span style="color:#66d9ef">we</span> <span style="color:#66d9ef">want</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">control</span> <span style="color:#66d9ef">this</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">----</span> <span style="color:#960050;background-color:#1e0010">&lt;-</span> <span style="color:#a6e22e">$sp</span> (<span style="color:#66d9ef">stack</span> <span style="color:#66d9ef">pointer</span>)
</span></span></code></pre></div><p>A stack buffer overflow occurs when we read way too much data and start overwriting adjacent variables.
The instruction pointer is just technically another variable on the stack. If we&rsquo;re not careful when writing to the
stack, we could accidentally run it over.
The stack canary is there to be intentionally the target of abuse.
Let&rsquo;s take a look at this stack frame after a buffer overflow attack (usually a bunch of A&rsquo;s):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">----</span> <span style="color:#960050;background-color:#1e0010">&lt;-</span> <span style="color:#a6e22e">$bp</span> (<span style="color:#66d9ef">base</span> <span style="color:#66d9ef">pointer</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">stack</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">int</span> <span style="color:#66d9ef">i</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">AAAAAAAAAAAAAAAAAAAAAAA</span><span style="color:#960050;background-color:#1e0010">&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">j</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">AAAAAAAAAAAAAAAAAAAAAAA</span><span style="color:#960050;background-color:#1e0010">&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">stack</span> <span style="color:#66d9ef">canary</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">AAAAAAAAAA</span><span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#960050;background-color:#1e0010">&lt;</span>--- <span style="color:#66d9ef">stack</span> <span style="color:#66d9ef">canary</span> <span style="color:#66d9ef">hit</span>! <span style="color:#66d9ef">abort</span>! <span style="color:#66d9ef">abort</span>!
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">instruction</span> <span style="color:#66d9ef">pointer</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">0x80000</span> <span style="color:#960050;background-color:#1e0010">&lt;</span>-- <span style="color:#66d9ef">we</span> <span style="color:#66d9ef">want</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">control</span> <span style="color:#66d9ef">this</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">----</span> <span style="color:#960050;background-color:#1e0010">&lt;-</span> <span style="color:#a6e22e">$sp</span> (<span style="color:#66d9ef">stack</span> <span style="color:#66d9ef">pointer</span>)
</span></span></code></pre></div><p>In the actual code of the program, the compiler will insert an additional function
before the function returns (reads from the instruction pointer) to check if the canary on the
stack matches the value of the canary in  a special region of memory similar to<code>.rodata</code>, a region of memory in the binary thats readonly.
that the attacker can never write to, since it&rsquo;s read only.
Let&rsquo;s compare what the code a developer would see, versus, what would actually get executed
on a lower level.
Here&rsquo;s our code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">20</span>];
</span></span><span style="display:flex;"><span>    fgets(buffer,<span style="color:#66d9ef">sizeof</span>(buffer)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,stdin);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%s&#34;</span>, buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, pretty clear-cut.
The control flow logic would go like this
<code>main() --&gt; fgets() --&gt; printf() --&gt; return/end()</code>
Let&rsquo;s take a look at what&rsquo;s actually happening:
<figure><img src="/images/ida_canary.png" width="80%"/>
</figure>

As you can see, a program that should be clear-cut, now has branches, conditional
checks, and a call to <code>__stack_chk_fail</code>.
The flow looks a little something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">main</span>() --<span style="color:#960050;background-color:#1e0010">&gt;</span> <span style="color:#66d9ef">fgets</span>() --<span style="color:#960050;background-color:#1e0010">&gt;</span> <span style="color:#66d9ef">printf</span>()--<span style="color:#960050;background-color:#1e0010">&gt;</span><span style="color:#66d9ef">check</span> <span style="color:#66d9ef">stack</span> <span style="color:#66d9ef">canary</span>()--<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">still</span> <span style="color:#66d9ef">the</span> <span style="color:#66d9ef">same</span> <span style="color:#66d9ef">end</span>()
</span></span><span style="display:flex;"><span>                                                    <span style="color:#960050;background-color:#1e0010">|</span>
</span></span><span style="display:flex;"><span>                                                    <span style="color:#960050;background-color:#1e0010">|</span><span style="color:#a6e22e">__</span><span style="color:#960050;background-color:#1e0010">&gt;</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">crash</span> <span style="color:#66d9ef">cuz</span> <span style="color:#66d9ef">something</span> <span style="color:#66d9ef">evil</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">happening</span>()
</span></span></code></pre></div><p>This clever little mechanism prevents an attacker from controlling where the function goes after finishing execution.</p>
<h3 id="how-to-detect-them-in-binaries">How to detect them in binaries</h3>
<p>There are two easy methods to check if there are canaries.
You can either check the binary for the functions that handle the canary verification:</p>
<h4 id="method-1">Method 1</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">&amp;&amp;</span> macho) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symtab) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (strcmp(name, <span style="color:#e6db74">&#34;___stack_chk_fail&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                        res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>This will of course not be possible since the symbols (names of functions) vanish
when the program is stripped and statically linked (packing all of the libraries
of the program together into one binary).</p>
<h4 id="method-2">Method 2</h4>
<p>Or you can look for data that looks like the canary getting moved around:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Look for x86_64 stack canary offset gs:[0x28] on macOS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((strstr(insn[i].op_str, <span style="color:#e6db74">&#34;gs:[0x28]&#34;</span>) <span style="color:#f92672">||</span> strstr(insn[i].op_str, <span style="color:#e6db74">&#34;gs:0x28&#34;</span>)) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;mov&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Look for x86 32-bit stack canary offset gs:[0x14] on macOS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((strstr(insn[i].op_str, <span style="color:#e6db74">&#34;gs:[0x14]&#34;</span>) <span style="color:#f92672">||</span> strstr(insn[i].op_str, <span style="color:#e6db74">&#34;gs:0x14&#34;</span>)) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;mov&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check for canary validation (x86)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (strstr(insn[i].op_str, <span style="color:#e6db74">&#34;gs:[0x28]&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;xor&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (strstr(insn[i].op_str, <span style="color:#e6db74">&#34;gs:[0x14]&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;xor&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>Since the canary is a very unique data type that resides in a particular
area of memory, it&rsquo;s easy to fingerprint its movement around in the program,
without even having access to function symbols.
99% of the time, if a datatype that looks like a canary is being moved
around, it&rsquo;s a canary.</p>
<h4 id="optional-method-3">Optional method 3</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>        <span style="color:#75715e">// ARM64 stack canary detection for iOS devices
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Look for stack canary loading from thread pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;ldr&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;ldur&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            (strstr(insn[i].op_str, <span style="color:#e6db74">&#34;x18&#34;</span>) <span style="color:#f92672">||</span> strstr(insn[i].op_str, <span style="color:#e6db74">&#34;tpidr_el0&#34;</span>))) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ARM32 stack canary patterns
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;ldr&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            (strstr(insn[i].op_str, <span style="color:#e6db74">&#34;pc&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> strstr(insn[i].op_str, <span style="color:#e6db74">&#34;___stack_chk_guard&#34;</span>))) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check for calls to ___stack_chk_fail (both x86 and ARM)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;call&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;bl&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;&amp;</span> 
</span></span><span style="display:flex;"><span>            strstr(insn[i].op_str, <span style="color:#e6db74">&#34;___stack_chk_fail&#34;</span>)) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>canary_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Arm has special mnemonics for calling and reading canaries, since it&rsquo;s a more modern
architecture built with security in mind.
Usually when you see these mnemonics, interacting with registers
that are designated for storing canaries, it&rsquo;s probably a canary being handled.</p>
<h2 id="pie">PIE</h2>
<h3 id="what-is-pie">What is PIE</h3>
<p>PIE, or position independent executable,
is another mitigation commonly found on most operating systems.
The idea is to randomize where program functions are located in memory, during runtime.
This is done to prevent an attacker that might have a stack buffer overflow primitive,
from having the ability to easily modify the control flow of the program
to suddenly redirect execution to another function.
This is done via randomization, making it so that the attacker either has to
leak what the address of a function he&rsquo;s interested in is, or via guessing which is
VERY HARD to do.</p>
<p>Here&rsquo;s what a program with and without PIE looks like
<figure><img src="/images/after_pie.png" width="80%"/>
</figure>

Where 0x40080 is the address before PIE, and will always be
0x40080.
And 0x00080 is the address after PIE,
where the first few zeros will be randomized at runtime.
The offset is the 80.
PIE randomized the base address, the part that is filled with 00000s.
So heres what addresses with and without PIE look like:</p>
<ul>
<li><code>0x0000000000400080</code> (before PIE)</li>
<li><code>0x00007f8a4b200080</code> (after PIE)</li>
</ul>
<p>Note that the <code>080</code> part stays the same, thats our offset.</p>
<h3 id="detecting-pie">Detecting PIE</h3>
<p>Detecting PIE is done via parsing the headers of the Mach-O
binary.
The headers of the binary are essentially metadata about the binary.
The metadata being stuff like:</p>
<ul>
<li>
<p>binary type (ELF/Mach-O)</p>
</li>
<li>
<p>binary architecture (arm/x86)</p>
</li>
<li>
<p>which mitigations are enabled (PIE, or NX)
Just by parsing the headers, we can glean a bunch
of info on the binary.
The Mach-O header structure looks like this:</p>
<p>Key Information:</p>
<ol>
<li>Magic Numbers: The first 4 bytes identify the file type:</li>
</ol>
<ul>
<li>0xfeedface (32-bit Mach-O)</li>
<li>0xfeedfacf (64-bit Mach-O)</li>
<li>0xcafebabe (fat binary containing multiple architectures)</li>
</ul>
<ol start="2">
<li>Header Structure (32-bit = 28 bytes, 64-bit = 32 bytes):</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> mach_header_64 {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> magic;      <span style="color:#75715e">// 0x00: Magic number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">uint32_t</span> cputype;    <span style="color:#75715e">// 0x04: CPU architecture
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">uint32_t</span> cpusubtype; <span style="color:#75715e">// 0x08: CPU variant
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">uint32_t</span> filetype;   <span style="color:#75715e">// 0x0C: Executable, library, etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">uint32_t</span> ncmds;      <span style="color:#75715e">// 0x10: Number of load commands
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">uint32_t</span> sizeofcmds; <span style="color:#75715e">// 0x14: Size of load commands
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">uint32_t</span> flags;      <span style="color:#75715e">// 0x18: FLAGS INCLUDING MH_PIE!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">uint32_t</span> reserved;   <span style="color:#75715e">// 0x1C: (64-bit only)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  };
</span></span></code></pre></div><ol start="3">
<li>PIE Detection: The MH_PIE flag is located in the flags field at offset 0x18. Its value is 0x00200000. When this bit is set, it indicates the binary supports Position Independent Execution.</li>
<li>Detection Process in machsec</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_pie</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> flags <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>is_64bit <span style="color:#f92672">?</span> macho<span style="color:#f92672">-&gt;</span>header<span style="color:#f92672">-&gt;</span>flags : ((<span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data)<span style="color:#f92672">-&gt;</span>flags;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> MH_PIE) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;PIE enabled&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_enabled <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No PIE&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pie_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="no-execute-nx">No eXecute (NX)</h2>
<h3 id="whats-nx">Whats NX?</h3>
<p>NX or no execute is another mitigation, where we mark the
stack/heap region as a non executable area of memory.
The reason this is done, is because
attackers used to be able to for example,
abuse a buffer overflow to write a bunch of malicious program logic
(straight up native assembly to the stack) and then just tell the program
to execute the data in the stack memory region.
The NX mitigation just straight up marks the entire memory region as a read/write memory
region ONLY, meaning attackers can no longer place malicious assembly code on the stack, redirect
execution to it, and expect it to run.</p>
<h3 id="detecting-nx">Detecting NX</h3>
<p>In order to detect NX, machsec does the following for the heap and the stack:</p>
<ol>
<li>NX Heap (detect_nx_heap):
<ul>
<li>Looks for __HEAP segment</li>
<li>Falls back to SEG_DATA segment if no heap segment</li>
<li>Checks if VM_PROT_EXECUTE (0x04) bit is set in initprot</li>
</ul>
</li>
<li>NX Stack (detect_nx_stack):
- Looks for __STACK segment
- Checks if VM_PROT_EXECUTE bit is set in initprot
- Assumes NX enabled if no explicit stack segment (modern macOS default)</li>
</ol>
<p>And here&rsquo;s how it&rsquo;s implemented in the code of machsec, for the stack and the heap respectively.
Stack:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check stack segments for NX protection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> segment_command_64 <span style="color:#f92672">*</span>stack_seg <span style="color:#f92672">=</span> macho_find_segment(macho, <span style="color:#e6db74">&#34;__STACK&#34;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> stack_nx <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if stack segment exists and is executable (bad for NX)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (stack_seg <span style="color:#f92672">&amp;&amp;</span> (stack_seg<span style="color:#f92672">-&gt;</span>initprot <span style="color:#f92672">&amp;</span> VM_PROT_EXECUTE)) {
</span></span><span style="display:flex;"><span>        stack_nx <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Heap:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">// Check heap segments for NX protection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> segment_command_64 <span style="color:#f92672">*</span>data_seg <span style="color:#f92672">=</span> macho_find_segment(macho, SEG_DATA);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> segment_command_64 <span style="color:#f92672">*</span>heap_seg <span style="color:#f92672">=</span> macho_find_segment(macho, <span style="color:#e6db74">&#34;__HEAP&#34;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> heap_nx <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if heap segment exists and is executable (bad for NX)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (heap_seg <span style="color:#f92672">&amp;&amp;</span> (heap_seg<span style="color:#f92672">-&gt;</span>initprot <span style="color:#f92672">&amp;</span> VM_PROT_EXECUTE)) {
</span></span><span style="display:flex;"><span>        heap_nx <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If no explicit heap segment, check data segment (where heap allocations often go)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>heap_seg <span style="color:#f92672">&amp;&amp;</span> data_seg <span style="color:#f92672">&amp;&amp;</span> (data_seg<span style="color:#f92672">-&gt;</span>initprot <span style="color:#f92672">&amp;</span> VM_PROT_EXECUTE)) {
</span></span><span style="display:flex;"><span>        heap_nx <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="rpathrunpath">RPATH/RUNPATH</h2>
<h3 id="what-is-rpathrunpath">What is rpath/runpath</h3>
<p>Rpath and runpath specify the paths where libraries are stored on the system.
for the program to use and load, <strong>at runtime</strong>.
The reason these are dangerous is due to the fact an attacker could replace these libraries
with modified libraries and thus control code execution, if the paths
defined are areas where the attacker can write code (the same dir as the binary, folders shared amongst users, etc).</p>
<h3 id="how-to-detect-rpathrunpath">How to detect rpath/runpath</h3>
<p>Detection Process</p>
<ol>
<li>Iterate Through Load Commands</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> load_command <span style="color:#f92672">*</span>cmd <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>load_commands;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> ncmds <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>is_64bit <span style="color:#f92672">?</span> macho<span style="color:#f92672">-&gt;</span>header<span style="color:#f92672">-&gt;</span>ncmds : ((<span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data)<span style="color:#f92672">-&gt;</span>ncmds;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ncmds; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The tool walks through all load commands in the Mach-O binary header.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2.</span> Check <span style="color:#66d9ef">for</span> LC_RPATH Commands
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (cmd<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">==</span> LC_RPATH) {
</span></span><span style="display:flex;"><span>      has_rpath <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>When it finds an LC_RPATH load command, it sets has_rpath = true. This indicates the binary has embedded library search paths.</p>
<ol start="3">
<li>Check for @rpath Usage in Library Dependencies</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (cmd<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">==</span> LC_LOAD_DYLIB) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> dylib_command <span style="color:#f92672">*</span>dylib <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> dylib_command <span style="color:#f92672">*</span>)cmd;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>path <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)dylib <span style="color:#f92672">+</span> dylib<span style="color:#f92672">-&gt;</span>dylib.name.offset;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (strstr(path, <span style="color:#e6db74">&#34;@rpath&#34;</span>)) {
</span></span><span style="display:flex;"><span>          has_runpath <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>For each LC_LOAD_DYLIB command (library dependency), it:</p>
<ul>
<li>Extracts the library path string</li>
<li>Checks if the path contains @rpath using strstr()</li>
<li>If found, sets has_runpath = true</li>
</ul>
<p>What It&rsquo;s Actually Looking For</p>
<ol>
<li>LC_RPATH entries: Hardcoded search paths like /usr/local/lib, /opt/lib, etc.</li>
<li>@rpath placeholders: Library paths like @rpath/MyFramework.framework/MyFramework</li>
</ol>
<p>Example Mach-O Structure</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>  <span style="color:#a6e22e">Load</span> <span style="color:#66d9ef">Commands</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">‚îú‚îÄ‚îÄ</span> LC_RPATH: <span style="color:#960050;background-color:#1e0010">/</span><span style="color:#a6e22e">usr</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">local</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">lib</span>        <span style="color:#960050;background-color:#1e0010">‚Üê</span> <span style="color:#66d9ef">Detected</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">RPATH</span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">‚îú‚îÄ‚îÄ</span> LC_LOAD_DYLIB: <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">rpath</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">lib.dylib</span> <span style="color:#960050;background-color:#1e0010">‚Üê</span> <span style="color:#66d9ef">Detected</span> <span style="color:#66d9ef">as</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">rpath</span> <span style="color:#66d9ef">usage</span>  
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">‚îî‚îÄ‚îÄ</span> <span style="color:#66d9ef">LC_LOAD_DYLIB</span>: <span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">usr</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">lib</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">libc.dylib</span> <span style="color:#960050;background-color:#1e0010">‚Üê</span> <span style="color:#66d9ef">Safe</span>, <span style="color:#66d9ef">ignored</span>
</span></span></code></pre></div><h2 id="fortify">FORTIFY</h2>
<h3 id="what-is-fortify">What is fortify?</h3>
<p>Fortify is a compiler flag to replace common memory unsafe functions
with functions that have bounds checking.
This mitigation is purely compiler level, and was created by the GNU compiler
later adopted by clang.
The main functions it targets are stuff like <code>memcpy()</code> and <code>memmove()</code>.
It&rsquo;s a relatively weak mitigation, but still something to be aware of.</p>
<h3 id="how-to-detect-fortify">How to detect fortify</h3>
<p>This mitigation modifies the way the functions work, which means the way
the code looks at the assembly level is also different from a binary that was
compiled without this mitigation.
<figure><img src="/images/foritfy.png" width="80%"/>
</figure>

As you can see, the memory unsafe functions like memcpy are now called
<code>__memcpy_chk()</code>. Essentially meaning the memcpy function was replaced
on the linking level with a more secure version.
If we just look for these symbols, we can detect this mitigation.
And here&rsquo;s what the code for the detection mechanism looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_fortify</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>symtab) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>fortify_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No symbols&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>fortify_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>fortify_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>fortified_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fortified_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>fortified_functions[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;memcpy_chk&#34;</span>, <span style="color:#e6db74">&#34;strcpy_chk&#34;</span>, <span style="color:#e6db74">&#34;strcat_chk&#34;</span>, <span style="color:#e6db74">&#34;sprintf_chk&#34;</span>, <span style="color:#e6db74">&#34;snprintf_chk&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;vsprintf_chk&#34;</span>, <span style="color:#e6db74">&#34;vsnprintf_chk&#34;</span>, <span style="color:#e6db74">&#34;gets_chk&#34;</span>, <span style="color:#e6db74">&#34;fgets_chk&#34;</span>, <span style="color:#e6db74">&#34;memset_chk&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;stpcpy_chk&#34;</span>, <span style="color:#e6db74">&#34;stpncpy_chk&#34;</span>, <span style="color:#e6db74">&#34;strncpy_chk&#34;</span>, <span style="color:#e6db74">&#34;strncat_chk&#34;</span>, <span style="color:#e6db74">&#34;vprintf_chk&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;printf_chk&#34;</span>, <span style="color:#e6db74">&#34;fprintf_chk&#34;</span>, <span style="color:#e6db74">&#34;vfprintf_chk&#34;</span>, <span style="color:#e6db74">&#34;read_chk&#34;</span>, <span style="color:#e6db74">&#34;recv_chk&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;recvfrom_chk&#34;</span>, <span style="color:#e6db74">&#34;readlink_chk&#34;</span>, <span style="color:#e6db74">&#34;getwd_chk&#34;</span>, <span style="color:#e6db74">&#34;realpath_chk&#34;</span>, <span style="color:#e6db74">&#34;wctomb_chk&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;wcstombs_chk&#34;</span>, <span style="color:#e6db74">&#34;mbstowcs_chk&#34;</span>, <span style="color:#e6db74">&#34;mbsrtowcs_chk&#34;</span>, <span style="color:#e6db74">&#34;wcrtomb_chk&#34;</span>, <span style="color:#e6db74">&#34;wcsrtombs_chk&#34;</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Remove leading underscore if present (common in Mach-O)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (name[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;_&#39;</span>) name<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Check against known fortified functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (size_t j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">sizeof</span>(fortified_functions) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(fortified_functions[<span style="color:#ae81ff">0</span>]); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (strstr(name, fortified_functions[j])) {
</span></span><span style="display:flex;"><span>                    fortified_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;  <span style="color:#75715e">// Don&#39;t double-count the same symbol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>fortified_count <span style="color:#f92672">=</span> fortified_count;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fortified_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>text_buffer <span style="color:#f92672">=</span> malloc(<span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (text_buffer) {
</span></span><span style="display:flex;"><span>            snprintf(text_buffer, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;FORTIFY enabled (%d functions)&#34;</span>, fortified_count);
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>fortify_text <span style="color:#f92672">=</span> text_buffer;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>fortify_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;FORTIFY enabled&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>fortify_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>fortify_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>fortify_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No FORTIFY&#34;</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>fortify_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>fortify_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="ubsan-undefined-behaviour-sanitizer">UBSAN (Undefined behaviour sanitizer)</h2>
<h3 id="what-is-ubsan">What is UBSAN?</h3>
<p>UBSAN is a compiler level mitigation that
introduces more checks into the program similarly to stack canaries
(We mitigate against exploits by adding checking functions into the code)
UBsan aims to catch undefined behaviors like integer bugs (int overflow, int underflow
signedness bugs).
Amongst other things.</p>
<h3 id="how-to-detect-ubsan">How to detect ubsan?</h3>
<p><figure><img src="/images/ubsan.png" width="80%"/>
</figure>

As you can see, we get a new function inserted into our code,
all we have to do is look for this symbol, and then we will know if ubsan is enabled or not.
Very similar idea to how detecting fortify works.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_ubsan</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>symtab) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>ubsan_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No symbols&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>ubsan_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>ubsan_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;__ubsan&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;__sanitizer&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;_ubsan_handle&#34;</span>)) {
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>ubsan_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UBSan enabled&#34;</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>ubsan_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>ubsan_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>ubsan_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No UBSan&#34;</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>ubsan_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>ubsan_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="asan-address-sanitizer">ASAN (Address Sanitizer)</h2>
<h3 id="what-is-asan">What is ASAN?</h3>
<p>The address sanitizer mitigation is primarily used in conjunction with
fuzzers to try and spot vulnerabilities like the powerful OOBW (Out of Bounds Write)
exploit primitive.
It works in much the same way as the previously discussed mitigations, and can be enabled
with a compiler flag.
However, the tradeoff to using this mitigation is huge since it adds a bunch of checks and functions to the
program, which significantly reduces the performance of the program.</p>
<h3 id="detecting-asan">Detecting ASAN</h3>
<p>Detecting ASAN works in much the same way as the previously discussed mitigations
Here&rsquo;s what a binary with the asan checks looks like:
<figure><img src="/images/asan.png" width="80%"/>
</figure>

As you can see, a bunch of asan functions get added.
And here&rsquo;s how the code detects asan:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_asan</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>symtab) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>asan_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No symbols&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>asan_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>asan_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;__asan&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;__sanitizer_cov&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;__interceptor_malloc&#34;</span>)) {
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>asan_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ASAN enabled&#34;</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>asan_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>asan_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>asan_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No ASAN&#34;</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>asan_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>asan_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span></code></pre></div><h2 id="cfi-control-flow-integrity">CFI (Control Flow Integrity)</h2>
<h3 id="what-is-cfi">What is CFI?</h3>
<p>CFI is an attempt at ensuring a program&rsquo;s proper control flow via in-program checks much like
the functions we have seen inserted into programs as part of other mitigations like UBSAN, ASAN
and canaries.
This is the most <strong>costly</strong> software mitigation of them all, since it will massively increase the binary
size, and the performance penalty is huge.
Unfortunately, this mitigation mostly applies to Linux/ELF binaries, since modern macOS/xnu machines
just use PAC, which is a hardware based implementation of control flow integrity, which I will discuss later in the post.</p>
<h3 id="detecting-cfi">Detecting CFI</h3>
<p>Detecting CFI works much like detecting the other previous instrumentation based mitigations, we just read the symbols
from the binary&hellip; and we&rsquo;re done.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_cfi</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// CFI is less common on macOS, check for symbols
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>symtab) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>cfi_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No symbols&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>cfi_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>cfi_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;__cfi&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;_cfi_&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;cfi_check&#34;</span>)) {
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>cfi_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;CFI enabled&#34;</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>cfi_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>cfi_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>cfi_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No CFI&#34;</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>cfi_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>cfi_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span></code></pre></div><h2 id="symbols-symbol-stripping">Symbols (Symbol Stripping)</h2>
<h3 id="what-is-symbol-stripping">What is symbol stripping</h3>
<p>Symbol stripping is not a mitigation per se, but a redaction of information that makes life for
reverse engineers harder.
When you give a function a name in a piece of code, the compiler doesn&rsquo;t really care/need the function
name in order to use the function, just a memory address of where that function is.
We humans however really need function names since they help us understand what the function does
at a glance without having to read the fun code.
Most programs will have their symbols removed so that a reverse engineer will not have the function names,
and be left with rather puzzling function names like <code>func_1234()</code> the names of the functions
generated obviously depend on your decompiler of choice.</p>
<h3 id="detecting-symbol-stripping">Detecting symbol stripping</h3>
<p>We detect symbol stripping via detecting if there are no symbols present, which is quite funny since most
mitigations we look for something that exists in the binary, but this one, we look for the nonpresence of something.
You can tell how many symbols are in a binary, as well as how many symbols are in the binary total, by just reading
the binary headers and metadata</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_symbols</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>symtab <span style="color:#f92672">||</span> symtab<span style="color:#f92672">-&gt;</span>nsyms <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Fully stripped (0 symbols)&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Count different types of symbols
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> local_syms <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, external_syms <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, undef_syms <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symbols[i].n_type <span style="color:#f92672">&amp;</span> N_EXT) {
</span></span><span style="display:flex;"><span>            external_syms<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ((symbols[i].n_type <span style="color:#f92672">&amp;</span> N_TYPE) <span style="color:#f92672">==</span> N_UNDF) {
</span></span><span style="display:flex;"><span>            undef_syms<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            local_syms<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>text_buffer <span style="color:#f92672">=</span> malloc(<span style="color:#ae81ff">128</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>text_buffer) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Memory error&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (local_syms <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        snprintf(text_buffer, <span style="color:#ae81ff">128</span>, <span style="color:#e6db74">&#34;Not stripped (%d symbols)&#34;</span>, symtab<span style="color:#f92672">-&gt;</span>nsyms);
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_text <span style="color:#f92672">=</span> text_buffer;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (external_syms <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> undef_syms <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        snprintf(text_buffer, <span style="color:#ae81ff">128</span>, <span style="color:#e6db74">&#34;Partially stripped (%d symbols)&#34;</span>, external_syms <span style="color:#f92672">+</span> undef_syms);
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_text <span style="color:#f92672">=</span> text_buffer;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        snprintf(text_buffer, <span style="color:#ae81ff">128</span>, <span style="color:#e6db74">&#34;Fully stripped (0 symbols)&#34;</span>);
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_text <span style="color:#f92672">=</span> text_buffer;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>symbols_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="stack-clashing">Stack Clashing</h2>
<h3 id="what-is-stack-clashing">What is stack clashing?</h3>
<p>Stack clashing is a very rare and recent exploit method that attempts
to make the stack region and the heap region of the program to intersect thus corrupting
the integral data that lives on the stack, stuff like function pointers, variables, etc.</p>
<h3 id="detecting-stack-clashing">Detecting stack clashing</h3>
<p>Detecting stack clashing, like most mitigations, is just a bunch of instrumentation the
compiler adds, a bunch of functions to check that the stack region hasn&rsquo;t intersected into
the heap region.
Since it&rsquo;s not really a thing on macOS/xnu, we can just assume that if canaries are present,
that check is also probably present.</p>
<h2 id="heap-cookies">Heap cookies</h2>
<h3 id="what-are-heap-cookies">What are heap cookies?</h3>
<p>Heap cookies are the same thing as stack canaries, but in the heap.
They check that heap chunks haven&rsquo;t been overflown.</p>
<h3 id="detecting-heap-cookies">Detecting heap cookies</h3>
<p>Detecting heap cookies can be done by checking the symbols in the binary.
Here&rsquo;s how to detect them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_heap_cookies</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>symtab) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>heap_cookies_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No symbols&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>heap_cookies_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>heap_cookies_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;malloc_zone&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;guard_malloc&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;_malloc_check&#34;</span>)) {
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>heap_cookies_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Heap hardening enabled&#34;</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>heap_cookies_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>heap_cookies_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>heap_cookies_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No heap hardening&#34;</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>heap_cookies_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>heap_cookies_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="integer-overflow">Integer overflow</h2>
<h3 id="what-is-integer-overflow">What is Integer overflow</h3>
<p>Integer overflow protection is another instrumentation based mitigation, where we add a bunch of functions
to the program to make sure that integers have not exceeded their limits and wrapped around to another value.</p>
<h3 id="detecting-integer-overflow">Detecting Integer Overflow</h3>
<p>Quite like the other mitigations, you can just check for the presence of certain symbols:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_integer_overflow</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>symtab) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>integer_overflow_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No symbols&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>integer_overflow_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>integer_overflow_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;__muloti4&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;__addoti4&#34;</span>) <span style="color:#f92672">||</span> 
</span></span><span style="display:flex;"><span>                strstr(name, <span style="color:#e6db74">&#34;__ubsan_handle_add_overflow&#34;</span>) <span style="color:#f92672">||</span> strstr(name, <span style="color:#e6db74">&#34;__wrap_&#34;</span>)) {
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>integer_overflow_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Integer overflow protection enabled&#34;</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>integer_overflow_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">-&gt;</span>integer_overflow_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="sandbox-xnu-exclusive">Sandbox (XNU exclusive)</h2>
<h3 id="what-is-sandboxing">What is sandboxing?</h3>
<p>In general, sandboxing is creating a restricted environment where a binary has limited
access to the underlying operating system.
In the case of XNU and mitigations, this mitigation does a couple of things:</p>
<ul>
<li>Filter syscalls (A bit like seccomp on Linux) using a kernel feature called seatbelt</li>
<li>Check entitlements (what is the binary allowed to access, what kind of hardware, etc.)</li>
<li>Apply a sandboxing profile based on the entitlements and the syscalls being filtered.</li>
</ul>
<h3 id="detecting-sandboxing">Detecting sandboxing</h3>
<p>We can detect sandboxing either via the symbols present, by checking if the binary is signed, which is also
a strong indicator that the binary is sandboxed, and also checking for strings that have to do with entitlements.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_sandbox</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> has_sandbox_symbols <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> has_code_signature <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> has_entitlements <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for sandboxing symbols
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (symtab) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Check for macOS/iOS sandboxing symbols
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;sandbox_&#34;</span>) <span style="color:#f92672">||</span> 
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;_sandbox_init&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;sandbox_check&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;sandbox_free_error&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;container_&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;_container_create&#34;</span>)) {
</span></span><span style="display:flex;"><span>                    has_sandbox_symbols <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for code signature and entitlements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> load_command <span style="color:#f92672">*</span>cmd <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>load_commands;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> ncmds <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>is_64bit <span style="color:#f92672">?</span> macho<span style="color:#f92672">-&gt;</span>header<span style="color:#f92672">-&gt;</span>ncmds : ((<span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data)<span style="color:#f92672">-&gt;</span>ncmds;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ncmds; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cmd<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">==</span> LC_CODE_SIGNATURE) {
</span></span><span style="display:flex;"><span>            has_code_signature <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Try to parse the code signature for entitlements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">struct</span> linkedit_data_command <span style="color:#f92672">*</span>sig_cmd <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> linkedit_data_command <span style="color:#f92672">*</span>)cmd;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Look for entitlement data in the signature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (sig_cmd<span style="color:#f92672">-&gt;</span>datasize <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>sig_data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> sig_cmd<span style="color:#f92672">-&gt;</span>dataoff;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Look for common sandbox entitlement strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (sig_cmd<span style="color:#f92672">-&gt;</span>datasize <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>) {  <span style="color:#75715e">// Minimum size check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// Search for sandbox-related entitlement keys
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (search_memory(sig_data, sig_cmd<span style="color:#f92672">-&gt;</span>datasize, <span style="color:#e6db74">&#34;com.apple.security.app-sandbox&#34;</span>, <span style="color:#ae81ff">31</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                        search_memory(sig_data, sig_cmd<span style="color:#f92672">-&gt;</span>datasize, <span style="color:#e6db74">&#34;platform-application&#34;</span>, <span style="color:#ae81ff">20</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                        search_memory(sig_data, sig_cmd<span style="color:#f92672">-&gt;</span>datasize, <span style="color:#e6db74">&#34;sandbox&#34;</span>, <span style="color:#ae81ff">7</span>)) {
</span></span><span style="display:flex;"><span>                        has_entitlements <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        cmd <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> load_command <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)cmd <span style="color:#f92672">+</span> cmd<span style="color:#f92672">-&gt;</span>cmdsize);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Determine sandbox status based on evidence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (has_sandbox_symbols) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Sandbox enabled (symbols)&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (has_entitlements) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Sandbox enabled (entitlements)&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (has_code_signature) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if this is a system binary (likely sandboxed)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">uint32_t</span> flags <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>is_64bit <span style="color:#f92672">?</span> macho<span style="color:#f92672">-&gt;</span>header<span style="color:#f92672">-&gt;</span>flags : ((<span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data)<span style="color:#f92672">-&gt;</span>flags;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> MH_PIE) {  <span style="color:#75715e">// System binaries are typically PIE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            res<span style="color:#f92672">-&gt;</span>sandbox_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Likely sandboxed (system binary)&#34;</span>;
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>sandbox_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>sandbox_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>sandbox_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Code signed (may be sandboxed)&#34;</span>;
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>sandbox_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>sandbox_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No sandbox&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>sandbox_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="hardened-runtime--sip---amfi-xnu-exclusive">Hardened runtime + SIP  + AMFI (XNU Exclusive)</h2>
<p>This is a suite of operating system/binary level mitigations
unique to macOS, some of them even unique to only iOS</p>
<h3 id="what-is-hardened-runtime">What is Hardened runtime?</h3>
<p>The hardened runtime is another mitigation set in place by XNU, set to mitigate against
library injection at runtime, debugging, injection of any unsigned code at runtime,
dynamic instrumentation, and the like, on a per process basis.
as well as adding some unique runtime mitigations.
Here&rsquo;s a breakdown of some of the things it will do:</p>
<ul>
<li><code>CS_RESTRICT</code>, a Mach-O header in the binary, part of the codesigning section of the binary metadata.
blocks <code>task_for_pid()</code>, essentially making the program not attachable by a debugger, unless they have the right entitlements</li>
<li><code>cs_kill</code> kernel kills the process if at any point during runtime signatures do not match</li>
<li>Library validation checks that all binaries are signed and have not been modified.</li>
<li>JIT Restriction - Just In Time compilation requires a memory region to be writeable &amp; executable, which is a security risk. This mitigation will not allow <code>mmap()</code>ing a memory region that&rsquo;s both write and execute, unless a specific entitlement is set: <code>com.apple.security.cs.allow-jit</code></li>
<li>Debugging - blocks ptrace() unless there is a specific entitlement:
<code>com.apple.security.get-task-allow</code></li>
</ul>
<h3 id="what-is-sip-system-integrity-protection">What is SIP (System Integrity Protection)</h3>
<p>SIP is a suite of these mitigations, that ensures the operating
system continues to operate whilst being resilient to malware, exploits,
and a stupid user accidentally deleting their entire filesystem because someone told them to <code>rm --rf /</code>
SIP can be disabled on macOS via the following command:
<code>csrutil -disable</code>
And is a must if you want to do any sort of offensive security like
dynamically instrumenting a program with FRIDA,
run a cracked program with the license validation libraries patched, etc.</p>
<h3 id="binary-encryption-amfi">Binary Encryption (AMFI)</h3>
<p>Apple Mobile File Integrity or AMFI
Is another mitigation that exists on XNU, specifically on iOS.
The mitigation consists of two components working in tandem:</p>
<ul>
<li>amfid (System Daemon)</li>
<li>kernel module (AppleMobileFileIntegrity.kext)
Together these two perform the following functions</li>
<li>Decrypt encrypted binaries:
Binaries have their <code>__TEXT</code> section encrypted, need to have the
section decrypted to run properly.
The Mach-O header has a <code>LC_ENCRYPTION_INFO</code> load command with:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-md" data-lang="md"><span style="display:flex;"><span>cryptid=1 (encrypted)
</span></span><span style="display:flex;"><span>cryptoff (offset to encrypted data)
</span></span><span style="display:flex;"><span>cryptsize (size of encrypted region)
</span></span></code></pre></div><p>Where the kernel does the signature verification,
amfid verifies cert chains, provisioning profiles, etc.</p>
<h3 id="detecting-siphardened-runtime">Detecting SIP/Hardened runtime</h3>
<p>Detecting if SIP is enabled on the operating system level is out of the scope of machsec, but it&rsquo;s safe to assume every XNU based operating system will have it enabled by default.
However, not all binaries will have a hardened runtime enabled, so we can definitely check for that in the binary.
We can check for the headers in the binary, which tell the kernel how to handle the binary. The same information that helps the kernel, helps us.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_hardened_runtime</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) { <span style="color:#75715e">// Check for LC_CODE_SIGNATURE load command (both macOS and iOS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> load_command <span style="color:#f92672">*</span>code_sig <span style="color:#f92672">=</span> macho_find_command(macho, LC_CODE_SIGNATURE);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Also check for iOS-specific security features
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//uint32_t flags = macho-&gt;is_64bit ? macho-&gt;header-&gt;flags : ((struct mach_header *)macho-&gt;data)-&gt;flags;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> has_ios_security <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for iOS App Store binaries (encrypted)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> load_command <span style="color:#f92672">*</span>encryption <span style="color:#f92672">=</span> macho_find_command(macho, LC_ENCRYPTION_INFO);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>encryption <span style="color:#f92672">&amp;&amp;</span> macho<span style="color:#f92672">-&gt;</span>is_64bit) {
</span></span><span style="display:flex;"><span>        encryption <span style="color:#f92672">=</span> macho_find_command(macho, LC_ENCRYPTION_INFO_64);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (encryption) {
</span></span><span style="display:flex;"><span>        has_ios_security <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (code_sig <span style="color:#f92672">||</span> has_ios_security) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (has_ios_security) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>hardened_runtime_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;iOS Security enabled&#34;</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>hardened_runtime_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hardened Runtime enabled&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>hardened_runtime_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>hardened_runtime_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>hardened_runtime_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No security hardening&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>hardened_runtime_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>hardened_runtime_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="code-signing">Code signing</h2>
<h3 id="what-is-code-signing">What is code signing?</h3>
<p>Similarly to windows, binaries distributed by known organizations/companies can get a digital signature from Apple, that helps an apple device tell
if a piece of software is a genuine copy from the software vendor, if the piece of software has been tampered with, etc.</p>
<h3 id="how-does-code-signing-work">How does code signing work?</h3>
<p>Code signing appends a signature blob at the end of the binary,
and there&rsquo;s a CodeDirectory (a structure containing metadata like flags
and an array of SHA256 hashes, one per 4KB page of executable code) with
precomputed hashes of every page that will get loaded into the __TEXT segment.</p>
<p>At runtime, the kernel verifies pages lazily via page faults - when
an executable page is first accessed, the kernel hashes it and compares
against the CodeDirectory. If hashes don&rsquo;t match, the process is killed.</p>
<p>Note: Only the __TEXT segment (executable code) is signed.
The following are NOT signed:</p>
<ul>
<li>Stack</li>
<li>Heap</li>
<li>__DATA (writable data)</li>
<li>__DATA_CONST (may be signed in some cases)</li>
<li>__LINKEDIT</li>
<li>Dynamically allocated memory</li>
</ul>
<h3 id="detecting-code-signing">Detecting code signing</h3>
<p>It&rsquo;s once again as simple as just parsing the binary headers.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_code_signing</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> load_command <span style="color:#f92672">*</span>code_sig <span style="color:#f92672">=</span> macho_find_command(macho, LC_CODE_SIGNATURE);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (code_sig) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>code_signing_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Code signed&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>code_signing_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>code_signing_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>code_signing_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Not code signed&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>code_signing_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>code_signing_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="pac-arm-exclusive">PAC (ARM Exclusive)</h2>
<h3 id="what-is-pac">What is PAC?</h3>
<p>PAC or pointer authentication codes is a unique mitigation only available on ARM hardware.
It&rsquo;s a mitigation that signs control-flow pointers (function pointers and return addresses) cryptographically, thus making control flow hijacking very hard.<br>
Since at the end of the day, most memory corruption attacks want to hijack the control flow of the program, this is one of the most powerful mitigations available to us on ARM-based platforms, which happen to be what Apple uses for their phones and recently, laptops.</p>
<h3 id="how-does-pac-work">How does PAC Work?</h3>
<p>PAC works by adding the following:</p>
<ul>
<li>Custom Instructions to ARM assembly which perform the pointer auth.</li>
<li>Custom accelerator circuits into the processor to assist in the cryptographic calculations necessary for PAC to work. This helps the security feature not be a burden on performance.</li>
<li>Custom Registers to the CPU, where keys are stored. Each register is 128 bits in size and inaccessible to user code.</li>
<li>Custom Encryption - Uses a new method of hashing called QARMA designed specifically to be more fast, less secure.</li>
</ul>
<p>PAC works by utilizing the unused bits of pointer addresses (no computer ever has 2^64, or 16 exabytes of memory).<br>
So by default, pointers look a little something like this:</p>
<p><code>0x00000002fa89efa8zz</code></p>
<p>Where there are a bunch of zeros that remain unused.<br>
PAC makes use of this to insert a little signature, so a signed pointer might look something like this:</p>
<p><code>0xA123A312fa89efa8</code></p>
<p>This hash gets computed using the following equation:</p>
<pre tabindex="0"><code class="language-math" data-lang="math">truncate(QARMA_encrypt(key, pointer, context))
</code></pre><p>Where:</p>
<p>Truncate - we cannot fit the whole result into the few bits we have, so we truncate to the 16 or 24 bits available.</p>
<p>QARMA - Custom ARM hasing algorthim, a tweakable block cipher algorthim.</p>
<p>key - secret key sitting in registers which can only be set by the kernel.</p>
<p>context - current value of the stack pointer, so that the function pointer can only be called within the context of the stackframe it resides in. This prevents just reusing a signed pointer from somewhere else in the program. The signed pointer will not work outside the proper stackframe (execution context); the signature calculated won‚Äôt match, and the process will crash.</p>
<p>However, it‚Äôs important to note that <em>PAC primarily signs instruction pointers, return addresses, and function pointers. Data pointers can be signed with PAC in some implementations, but this is limited by C language constraints (pointer arithmetic, pointer-to-integer casts, etc).</em>
Unfortunately, due to the way the C spec is defined, it‚Äôs impossible to sign all the pointers without completely breaking everything.
Since C allows you to do things like pointer arithmetic and interact with pointers as a datatype, any interaction with a pointer as a datatype would cause an exception in the way PAC works.</p>
<p>Thus, only pointers that are generally not going to be messed around with by a C program, things like instruction pointers, we can safely sign them, since they are not going to be modified intentionally by program logic.</p>
<h3 id="detecting-pac">Detecting PAC</h3>
<p>Here&rsquo;s a picture of what PAC looks like in a program (<code>/bin/ls</code>).
<figure><img src="/images/pac.png" width="80%"/>
</figure>

As you can see, we get new cool arm instructions like</p>
<ul>
<li>PACZIA (Sign pointer with context of &ldquo;0&rdquo;)</li>
<li>AUTIBSP (Auth Pointer using key B)</li>
</ul>
<p>So the detection mechanism just needs to detect the new instructions.
Or if the disassembler hasn&rsquo;t been updated with handling these new instructions, we can just resort back to symbols.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_pac</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// PAC (Pointer Authentication Code) is available on ARM64 devices
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> cputype <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>is_64bit <span style="color:#f92672">?</span> macho<span style="color:#f92672">-&gt;</span>header<span style="color:#f92672">-&gt;</span>cputype : ((<span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data)<span style="color:#f92672">-&gt;</span>cputype;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// PAC is only available on ARM64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (cputype <span style="color:#f92672">!=</span> CPU_TYPE_ARM64) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;N/A (not ARM64)&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for PAC-related symbols
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (symtab) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Check for PAC-related symbols
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;_ptrauth&#34;</span>) <span style="color:#f92672">||</span> 
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;pac_&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;_auth_&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;pointer_auth&#34;</span>)) {
</span></span><span style="display:flex;"><span>                    res<span style="color:#f92672">-&gt;</span>pac_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;PAC enabled&#34;</span>;
</span></span><span style="display:flex;"><span>                    res<span style="color:#f92672">-&gt;</span>pac_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                    res<span style="color:#f92672">-&gt;</span>pac_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check CPU subtype for PAC capability
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> cpusubtype <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>is_64bit <span style="color:#f92672">?</span> macho<span style="color:#f92672">-&gt;</span>header<span style="color:#f92672">-&gt;</span>cpusubtype : ((<span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data)<span style="color:#f92672">-&gt;</span>cpusubtype;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Mask out feature flags to get the actual subtype
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> actual_subtype <span style="color:#f92672">=</span> cpusubtype <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>CPU_SUBTYPE_MASK;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Apple Silicon and newer ARM64 chips support PAC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (actual_subtype <span style="color:#f92672">==</span> CPU_SUBTYPE_ARM64E) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if this binary has the PAC ABI flag set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cpusubtype <span style="color:#f92672">&amp;</span> CPU_SUBTYPE_PTRAUTH_ABI) {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>pac_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;PAC enabled (ARM64E with PtrAuth ABI)&#34;</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>pac_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;PAC capable (ARM64E)&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (actual_subtype <span style="color:#f92672">==</span> CPU_SUBTYPE_ARM64_V8) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;PAC capable (ARM64)&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>pac_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Default: ARM64 device but no PAC detected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    res<span style="color:#f92672">-&gt;</span>pac_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No PAC detected&#34;</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>pac_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">-&gt;</span>pac_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>MTE (ARM Exclusive)</p>
<h2 id="what-is-emtemtemie">What is EMTE/MTE/MIE</h2>
<p>MTE or Memory Tagging Extension is a brand new mitigation (as of time of writing) that Apple/ARM developed to protect the pointers that PAC cannot. They both use the principle that there are unused bits in each pointer&rsquo;s address we can utilize, but that&rsquo;s about where the similarities end.</p>
<h2 id="how-mte-works">How MTE Works</h2>
<p>A randomly generated 4-bit tag from hardware RNG is added to both the pointer and stored in tag memory for that allocation. Let&rsquo;s give a practical example of how MTE would stop a UAF Bug. Here&rsquo;s our piece of code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> malloc(<span style="color:#ae81ff">64</span>); <span style="color:#75715e">// alloc chunk on heap size 64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ptr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>; <span style="color:#75715e">// set value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>free(ptr); <span style="color:#75715e">//mark chunk as empty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ptr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span>;  <span style="color:#75715e">// UAF bug (continuing the use of the chunk after it was freed, could be populated with anything now...)
</span></span></span></code></pre></div><p>Here&rsquo;s what&rsquo;s happening on the assembly level:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">MOV</span> <span style="color:#66d9ef">x0</span>, <span style="color:#75715e">#64 // move size 64 to argument register for malloc()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">BL</span> <span style="color:#66d9ef">malloc</span> <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">call</span> <span style="color:#66d9ef">function</span> <span style="color:#66d9ef">malloc</span>
</span></span></code></pre></div><p>This is our chunk allocation. Let&rsquo;s assume everything worked and we get the following heap address <code>0x0000001234567890</code>, moved into register <code>x0</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">IRG</span> <span style="color:#66d9ef">x0</span>, <span style="color:#66d9ef">x0</span>
</span></span></code></pre></div><p>IRG stands for &ldquo;Insert Random Tag&rdquo;, this is the part that generates the random tag, and puts it in the unused bits of our pointer.
Here&rsquo;s what our pointer looks like now:</p>
<pre tabindex="0"><code>0x0300001234567890
</code></pre><p>Now, we need to tag the memory itself.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">STG</span> <span style="color:#66d9ef">x0</span>, [<span style="color:#66d9ef">x0</span>]
</span></span></code></pre></div><p>This is accomplished by writing the tag to a special section of RAM metadata called tag memory, that&rsquo;s separate from the memory accessible to userspace. Tag memory at address <code>0x1234567890</code> now stores tag <code>3</code>.</p>
<p>Now let&rsquo;s write to the heap:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">MOV</span> <span style="color:#66d9ef">w1</span>, <span style="color:#75715e">#&#39;A&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">STRB</span> <span style="color:#66d9ef">w1</span>, [<span style="color:#66d9ef">x0</span>]
</span></span></code></pre></div><p>Now that we wrote A to the memory area tagged with 3, everything is ready! Let&rsquo;s see what happens when we free:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">IRG</span> <span style="color:#66d9ef">x1</span>, <span style="color:#66d9ef">x0</span>          <span style="color:#75715e">; generate new random tag in x1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">STG</span> <span style="color:#66d9ef">x1</span>, [<span style="color:#66d9ef">x0</span>]        <span style="color:#75715e">; write new tag to tag memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">BL</span> <span style="color:#66d9ef">free</span>
</span></span></code></pre></div><p>A few things just happened:</p>
<ul>
<li>The memory allocation is marked as free.</li>
<li>The tagged pointer to the chunk, <code>0x0300001234567890</code> remains the same.</li>
<li>Tag memory at address <code>0x1234567890</code> gets rewritten with a new random tag, for example, <code>0xA</code>.</li>
</ul>
<p>Now let&rsquo;s see what happens when the UAF is happening on the assembly level.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">MOV</span> <span style="color:#66d9ef">w1</span>, <span style="color:#75715e">#&#39;B&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">STRB</span> <span style="color:#66d9ef">w1</span>, [<span style="color:#66d9ef">x0</span>]
</span></span></code></pre></div><p>The <code>STRB</code> alongside other instructions like <code>LDR</code> automagically perform the tag check in the background. As you can see, in the UAF, there is no tag generation. And the old tag that was assigned to that heap chunk no longer matches the tag in the pointer. STRB instruction will now crash due to tag mismatch with a synchronous exception.</p>
<h3 id="detecting-mte">Detecting MTE</h3>
<p>Detecting MTE took a bit of research work, since it&rsquo;s a new mitigation.
I had to extract the JavaScriptCore engine from iOS 26.1 on the new iPhone since that&rsquo;s the only thing that has that mitigation right now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">detect_mie</span>(<span style="color:#66d9ef">struct</span> DetectionResults <span style="color:#f92672">*</span>res, cs_insn <span style="color:#f92672">*</span>insn, size_t count, macho_t <span style="color:#f92672">*</span>macho) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// MIE (Memory Integrity Enforcement) / EMTE (Enhanced Memory Tagging Extension)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// is only available on ARM64 devices
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> cputype <span style="color:#f92672">=</span> macho<span style="color:#f92672">-&gt;</span>is_64bit <span style="color:#f92672">?</span> macho<span style="color:#f92672">-&gt;</span>header<span style="color:#f92672">-&gt;</span>cputype : ((<span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data)<span style="color:#f92672">-&gt;</span>cputype;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cputype <span style="color:#f92672">!=</span> CPU_TYPE_ARM64) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;N/A (not ARM64)&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_color <span style="color:#f92672">=</span> COLOR_YELLOW;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> has_mte_instructions <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> has_mte_symbols <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mte_instruction_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for MTE/EMTE instructions in disassembly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (insn <span style="color:#f92672">&amp;&amp;</span> count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Check for MTE-specific ARM64 instructions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// IRG - Insert Random Tag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;irg&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// STG - Store Allocation Tag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;stg&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ST2G - Store Allocation Tags (double)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;st2g&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// STZ2G - Store Allocation Tags and Zero (double)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;stz2g&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// STZG - Store Allocation Tag and Zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;stzg&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// LDG - Load Allocation Tag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;ldg&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ADDG - Add with Tag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;addg&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// SUBG - Subtract with Tag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;subg&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// GMI - Tag Mask Insert
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;gmi&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// SUBP/SUBPS - Subtract Pointer (used with MTE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;subp&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> strcmp(insn[i].mnemonic, <span style="color:#e6db74">&#34;subps&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                has_mte_instructions <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                mte_instruction_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for MTE/EMTE-related symbols
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> symtab_command <span style="color:#f92672">*</span>symtab <span style="color:#f92672">=</span> macho_get_symtab(macho);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (symtab) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>symbols <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> nlist_64 <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>symoff);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>strings <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)macho<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> symtab<span style="color:#f92672">-&gt;</span>stroff;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>nsyms; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (symbols[i].n_un.n_strx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> symbols[i].n_un.n_strx <span style="color:#f92672">&lt;</span> symtab<span style="color:#f92672">-&gt;</span>strsize) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name <span style="color:#f92672">=</span> strings <span style="color:#f92672">+</span> symbols[i].n_un.n_strx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Check for MTE/EMTE-related symbols (be specific to avoid false positives)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (strstr(name, <span style="color:#e6db74">&#34;_mte_&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;_emte_&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;memory_tagging&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;__hwasan&#34;</span>) <span style="color:#f92672">||</span>  <span style="color:#75715e">// Hardware-assisted AddressSanitizer uses MTE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    strstr(name, <span style="color:#e6db74">&#34;hwaddress&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    (strstr(name, <span style="color:#e6db74">&#34;tagged&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> strstr(name, <span style="color:#e6db74">&#34;ptr&#34;</span>)) <span style="color:#f92672">||</span>  <span style="color:#75715e">// tagged_ptr but not just any &#34;tagged&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    strstr(name, <span style="color:#e6db74">&#34;_irg&#34;</span>) <span style="color:#f92672">||</span>  <span style="color:#75715e">// MTE instruction functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    strstr(name, <span style="color:#e6db74">&#34;_stg&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;_ldg&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;_addg&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    strstr(name, <span style="color:#e6db74">&#34;_subg&#34;</span>)) {
</span></span><span style="display:flex;"><span>                    has_mte_symbols <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Determine MIE/EMTE status
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (has_mte_instructions) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>text_buffer <span style="color:#f92672">=</span> malloc(<span style="color:#ae81ff">128</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (text_buffer) {
</span></span><span style="display:flex;"><span>            snprintf(text_buffer, <span style="color:#ae81ff">128</span>, <span style="color:#e6db74">&#34;MIE/EMTE enabled (%d MTE instructions)&#34;</span>, mte_instruction_count);
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>mie_text <span style="color:#f92672">=</span> text_buffer;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">-&gt;</span>mie_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;MIE/EMTE enabled&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (has_mte_symbols) {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;MIE/EMTE enabled (symbols)&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_color <span style="color:#f92672">=</span> COLOR_GREEN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No MIE/EMTE detected&#34;</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_status <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">-&gt;</span>mie_color <span style="color:#f92672">=</span> COLOR_RED;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, I had to use a two-pronged approach, looking for symbols
and the actual disassembly from the disassembler.
This detection method is actively looking for instructions in arm64
that are related to memory tagging. These instructions are brand new, and thus some disassemblers don&rsquo;t support them and can&rsquo;t parse them.
But this is the best method of detecting it.</p>
<h2 id="arc-objectivec">ARC (ObjectiveC)</h2>
<h3 id="what-is-arc">What is ARC?</h3>
<p>ARC, or Automatic Reference Counting, is a mitigation available in the Swift/Objective-C programming languages, that does reference counting
in order to make UAFs harder in Objective-C and Swift, since all of the higher level objects and data structures you create are stored in the heap.</p>

        </div>

        
        <footer class="post-footer">
            <div class="post-tags">
                <h4>Tags</h4>
                <div class="tag-list">
                    
                    <span class="tag">#example</span>
                    
                    <span class="tag">#analysis</span>
                    
                </div>
            </div>
        </footer>
        
    </article>
</div>

        </main>

        <footer class="site-footer">
    <div class="footer-content">
        <div class="footer-section">
            <h3>gracecondition</h3>
            <p>OS internals, binary exploitation, and low-level security research</p>
        </div>

        <div class="footer-section">
            <h4>Quick Links</h4>
            <ul>
                <li><a href="/posts/">Posts</a></li>
                <li><a href="/articles/">Articles</a></li>
                <li><a href="/ctf/">CTF Solutions</a></li>
                <li><a href="/about/">About</a></li>
            </ul>
        </div>

        <div class="footer-section">
            <h4>Connect</h4>
            <div class="social-links">
                
                
                
            </div>
        </div>
    </div>

    <div class="footer-bottom">
        <p>&copy; 2025 gracecondition. All rights reserved.</p>
    </div>
</footer>
    </div>

    <script src="https://gracecondition.github.io/js/main.js"></script>
    
</body>
</html>
